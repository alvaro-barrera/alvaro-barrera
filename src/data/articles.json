[
    {
        "slug": "mecanismos-en-la-complejidad-del-software",
        "previous": "arquitectura-software",
        "next": "",
        "title": "Mecanismos para Gestionar la Complejidad del Software",
        "date": "23/11/2024",
        "summary": "Mecanismos para la gestión de la complejidad del software: Abstracción, Encapsulación, Modularidad y Jerarquía",
        "content": "En la mayoría de los casos, la naturaleza del software es compleja, ya que está influenciada tanto por el entorno tecnológico como por el contexto de negocio. Este entorno se describe en los requisitos y la arquitectura, pero también, la interacción entre los elementos del sistema y el diseño, contribuyen a su complejidad.<br /><br />Sin embargo, contamos con cuatro mecanismos fundamentales que nos facilitan este proceso:<br /><br /><ul><li>Abstracción</li><li>Encapsulación</li><li>Modularidad</li><li>Jerarquía</li></ul><h2><b>Abstracción</b></h2>La abstracción consiste en simplificar y representar los aspectos esenciales de un sistema, omitiendo detalles menos relevantes (al menos por el momento).<br /><br />Este proceso surge de la necesidad de enfocarnos en los aspectos más importantes para el contexto actual, dejando de lado la información no relevante y resaltando las características comunes de los modelos que representan la realidad.<br /><br /><h5>Intención</h5>La abstracción busca identificar características comunes entre objetos, delimitando responsabilidades y comportamientos, dentro del dominio de un problema.<br /><br />Este proceso es subjetivo, ya que depende de la perspectiva del observador y del contexto en el que se aplique.<br /><br /><h2><b>Encapsulación</b></h2>La encapsulación consiste en ocultar los detalles internos de una abstracción, los cuales no son necesarios para funcionamiento externo, protegiendo así su estado y asegurando que solo se acceda a ella de forma controlada.<br /><br /><h5>Intención</h5>La encapsulación permite modificar las implementaciones internas sin afectar a los elementos que dependen de ellas, lo que facilita el mantenimiento del sistema y la mejora de su flexibilidad sin comprometer la seguridad o integridad de los datos.<br /><br /><h2><b>Modularidad</b></h2>La modularidad es el proceso mediante el cual se descompone un sistema en partes más pequeñas y manejables, con bajo acoplamiento y alta cohesión.<br /><br /><h5>Intención</h5>La modularidad permite dividir la complejidad del software en componentes comprensibles y autónomos.<br /><br />Esto no solo facilita la comprensión del sistema, sino que también permite actualizar o modificar las partes sin afectar el comportamiento global del sistema. Los módulos son diseñados para ser independientes entre sí, pero con una fuerte cohesión interna en sus responsabilidades.<br /><br /><h2><b>Jerarquía</b></h2>La jerarquía es la clasificación y organización estructurada de las abstracciones, distribuyéndolas en diferentes niveles. Estos niveles pueden ser determinados por diversos factores, como la responsabilidad, el comportamiento, la composición, etc...<br /><br />Nos sirven para organizar los elementos de un sistema, de manera que su comprensión y mantenimiento sean más eficientes.<br /><br /><h5>Intención</h5>La jerarquización de abstracciones mejora la comprensión del problema, estructurando la información en niveles. Dentro de cada nivel, los objetos tienden a colaborar entre sí, lo que reduce la complejidad.<br /><br />En muchos sistemas complejos, no existe una única estructura jerárquica, sino que pueden coexistir varias jerarquías adaptadas a distintos aspectos del problema."
    },
    {
        "slug": "arquitectura-software",
        "previous": "disenio-en-el-proceso-de-software",
        "next": "mecanismos-en-la-complejidad-del-software",
        "title": "Arquitectura de Software",
        "date": "23/08/2024",
        "summary": "Introducción a la Arquitectura de Software, roles de diseñador y arquitecto",
        "content": "Con una buena arquitectura, el software debería ser:<br/>1. Flexible<br/>2. Reusable/reutilizable<br/>3. Mantenible<br/><br/>Es esencial conocer y aplicar principios de diseño. Para comunicar estos principios, utilizamos una notación visual llamada UML (Lenguaje Unificado de Modelado). Si no entiendes por qué las piezas están donde están, es una señal de que el diseño del proyecto no ha sido adecuado desde el principio.<br/><br/><h5>Diferencia entre el diseño y la arquitectura de software</h5><br/>El diseñador de software es responsable de esbozar y proponer una solución de software para resolver un problema, detallando los componentes individuales y sus responsabilidades. En esta etapa, se busca convertir los requisitos en código funcional y fácil de mantener a largo plazo.<br/><br/>El arquitecto de software es responsable de analizar el sistema, elegir el marco de trabajo, seleccionar el almacenamiento de datos y determinar cómo cada componente interactúa con los demás.<br/><br/>Entonces, el diseño de software se ocupa de los aspectos de nivel inferior de un sistema, en cambio, la arquitectura de software considera el panorama completo, que incluye los aspectos de nivel superior del sistema y los problemas comerciales que se deben resolver. Ambos roles deben ser capaces de comunicar soluciones de alta calidad de manera efectiva a las partes interesadas.<br/><br/>Uno de los desafíos clave en la arquitectura de software es encontrar el equilibrio óptimo entre velocidad y calidad. A menudo, el cliente desea recibir su software y los resultados que este proporciona lo más rápido posible, mientras que el equipo de ingeniería se esfuerza por entregar un sistema robusto, bien diseñado e implementado. Dada esta situación, la negociación es inevitable y necesaria. Encontrar un equilibrio es crucial para producir un software que cumpla con las expectativas de ambas partes."
    },
    {
        "slug": "disenio-en-el-proceso-de-software",
        "previous": "arquitectura-software",
        "next": "introduccion-al-modelado-orientado-a-objetos",
        "title": "Diseño en el Proceso de Software",
        "date": "23/08/2024",
        "summary": "Diseño conceptual y técnico en el desarrollo de software",
        "content": "El desarrollo de software es un proceso iterativo, donde se añaden y refinan los requisitos en cada iteración hasta alcanzar una solución final.<br/><br/>Durante la etapa de diseño, actuamos como arquitectos para estructurar y definir el comportamiento del software. Es fundamental basarse en la recopilación de requisitos, escuchar al cliente y hacer preguntas relevantes y esclarecedoras.<br/><br/>Con los requisitos iniciales, podemos idear una solución, que se traduce en un diseño conceptual. Este diseño conceptual se convierte en un diseño técnico, con la creación de maquetas conceptuales y diagramas técnicos.<br/><br/>Las maquetas conceptuales ofrecen ideas iniciales para cumplir con los requisitos, enfocándose en la estructura del software, identificando componentes y sus relaciones, sin entrar en detalles técnicos.<br/><br/>En el diseño técnico, describimos cómo cada componente cumplirá con sus responsabilidades. Dividimos cada componente en partes más pequeñas y específicas. Al entender la composición de los componentes, podemos diseñarlos en detalle.<br/><br/>La comunicación y el feedback son esenciales en el diseño de la solución. Si los componentes y sus conexiones en el diseño conceptual no son alcanzables en el diseño técnico, debemos volver al diseño conceptual. Si las decisiones de diseño han sido validadas con el cliente y son viables técnicamente, los diagramas técnicos servirán para coordinar el trabajo con el equipo de ingeniería."
    },
    {
        "slug": "disenio-de-software-calidad-vs-tiempo-de-comercializacion",
        "previous": "introduccion-al-modelado-orientado-a-objetos",
        "next": "",
        "title": "Diseño de Software: Calidad vs. Tiempo de Comercialización (GTM)",
        "date": "24/08/2024",
        "summary": "Equilibrar la calidad y tiempo en las decisiones del diseño de software",
        "content": "Tomar decisiones de diseño de software implica encontrar un equilibrio entre varios atributos de calidad, como rendimiento, usabilidad y seguridad. Sin embargo, al profundizar en el análisis, surgen otros criterios igualmente importantes, como el mantenimiento, la escalabilidad del sistema y, desde una perspectiva empresarial, el tiempo de comercialización (GTM o Go to Market). En muchas ocasiones, la presión por lanzar nuevas funcionalidades rápidamente puede comprometer estos atributos.<br/><br/>Como arquitectos de software, tenemos la responsabilidad de abogar por la calidad dentro del contexto empresarial, buscando un balance adecuado entre los diferentes criterios, especialmente cuando se trata de priorizar la calidad frente al GTM. Esto requiere una comprensión integral de las necesidades tanto del negocio como del sistema técnico.<br/><br/>Desde otra perspectiva, el arquitecto debe aplicar un juicio adecuado para determinar qué nivel de calidad es aceptable en cada situación. Aunque el objetivo ideal podría ser alcanzar una cobertura de código del 100%, pruebas exhaustivas en todas las plataformas o navegadores, y la capacidad de soportar cargas masivas, es necesario identificar qué criterios pueden ser negociables y cuáles son indispensables para el éxito del proyecto.<br/><br/>El contexto empresarial es clave para tomar decisiones informadas sobre cómo equilibrar los atributos de calidad. Mantener un diálogo abierto con los interesados, ya sean los dueños del producto, los usuarios finales o los ingenieros, permite comprender las prioridades y limitaciones. Además, considerar diversas perspectivas sobre el diseño técnico de la solución ayudará a garantizar que se tomen decisiones más completas y alineadas con los objetivos del negocio y del producto."
    },
    {
        "slug": "introduccion-al-modelado-orientado-a-objetos",
        "previous": "disenio-en-el-proceso-de-software",
        "next": "clasificacion-de-objetos-en-la-programacion-orientada-a-objetos",
        "title": "Introducción al Modelado Orientado a Objetos",
        "date": "24/08/2024",
        "summary": "Pensamiento orientado a objetos y algunos ejemplos",
        "content": "¿Qué encuentras cuando miras a tu alrededor? Una laptop, una mesa, una silla, incluso tú mismo o la habitación en su totalidad, son todos objetos.<br/><br/>¿Por qué deberíamos representarlos como objetos en el código? Para mantenerlo organizado, flexible y reutilizable.<br/><br/>De los ejemplos anteriores, podemos extraer detalles específicos asociados a cada uno de ellos. Por tanto, podemos decir que un objeto tiene responsabilidades o comportamientos propios.<br/><br/>En el modelado orientado a objetos, tanto los objetos físicos como los conceptos abstractos pueden ser representados como objetos con características y comportamientos. Por ejemplo, una persona tiene un nombre, una edad y una estatura, además de comportamientos particulares como abrir la laptop, escribir o sentarse. Por otro lado, un pedido en un sistema de compras tiene un número, una fecha, una lista de productos, y comportamientos como ser enviado o cancelado.<br/><br/>Cuando utilizamos el modelado orientado a objetos, pensamos en términos de objetos que tienen atributos (características) y métodos (comportamientos). Estos objetos interactúan entre sí para cumplir con las funciones del sistema.<br/><br/>Tengamos en cuenta que la programación orientada a objetos también nos permite reutilizar código mediante la herencia, donde una clase 'hija' hereda las características y comportamientos de una clase 'padre'. Esto nos evita repetir código innecesariamente y facilita el mantenimiento de la aplicación.<br/><br/>Finalmente, es importante mencionar que, en algunas ocasiones, para resolver problemas simples o más directos, no es necesario utilizar un enfoque orientado a objetos. En esos casos, un enfoque procedimental o estructurado puede ser más eficiente y adecuado para el desarrollo rápido de soluciones."
    },
    {
        "slug": "clasificacion-de-objetos-en-la-programacion-orientada-a-objetos",
        "previous": "introduccion-al-modelado-orientado-a-objetos",
        "next": "disenio-conceptual-con-tarjetas-crc",
        "title": "Clasificación de Objetos en Programación Orientada a Objetos",
        "date": "24/08/2024",
        "summary": "Clasificación y roles de objetos en POO: entidad, frontera y control",
        "content": "En la programación orientada a objetos (POO), los tipos de objetos se pueden clasificar en tres categorías principales:<br/><br/><h5>Objetos de Entidad</h5><br/>Los objetos de entidad representan elementos del mundo real o conceptos que se modelan en el sistema, estos son la primera capa de abstracción al descomponer los objetos que conforman el sistema. Estos objetos suelen ser los más comunes y se utilizan para representar datos o información específica del dominio del problema. Por ejemplo, un objeto entidad ‘Vehículo’ podría tener atributos como marca, modelo, año, y kilometraje, y estaría sujeto a reglas de negocio relacionadas con el funcionamiento y la gestión de vehículos.<br/><br/><h5>Objetos de Frontera</h5><br/>Los objetos de frontera (también llamados objetos de interfaz, de presentación o límite) interactúan con el exterior del sistema, como usuarios, otros sistemas, o interfaces de red. Ejemplos incluyen formularios de entrada de datos, interfaces de usuario, y criterios de autenticación. Por ejemplo, un objeto de frontera podría ser un formulario de inicio de sesión donde los usuarios ingresan sus credenciales, y el sistema valida estos datos según ciertos requisitos de seguridad.<br/><br/><h5>Objetos de Control</h5><br/>Los objetos de control gestionan la lógica de flujo de los casos de uso o las interacciones dentro del sistema. Actúan como mediadores entre los objetos de entidad y los objetos de frontera, facilitando la comunicación y el procesamiento de datos. Ejemplos de objetos de control incluyen los ‘loaders’ (cargadores o barras de progreso) que indican el progreso de una tarea o  estado del mismo al usuario que interactúa con el sistema, y los botones que inician acciones específicas como guardar, eliminar o enviar. Además, estos objetos pueden manejar la coordinación de múltiples objetos de entidad para cumplir con un caso de uso."
    },
    {
        "slug": "disenio-conceptual-con-tarjetas-crc",
        "previous": "clasificacion-de-objetos-en-la-programacion-orientada-a-objetos",
        "next": "disenio-de-software-acoplamiento-y-cohesion",
        "title": "Diseño Conceptual con Tarjetas CRC: Ejemplos y Beneficios",
        "date": "24/08/2024",
        "summary": "Uso de tarjetas CRC para organizar y visualizar el diseño conceptual",
        "content": "Cuando iniciamos el diseño conceptual, identificamos los componentes, sus relaciones y responsabilidades en el contexto del problema a resolver o el requisito a cumplir.<br/><br/>Una técnica útil para organizar el diseño conceptual es el uso de tarjetas CRC (Clase, Responsabilidad, Colaborador). Estas tarjetas ayudan a identificar los componentes como clases, sus responsabilidades y las colaboraciones o conexiones entre ellas.<br/><br/>Cada tarjeta CRC consta de tres partes: el nombre de la clase, sus responsabilidades y los colaboradores (otras clases) con las que interactúa para cumplir dichas responsabilidades.<br/><br/><h5>Ejemplo de Tarjeta CRC para la Clase Venta:</h5><br/><div class='scroll'><table><thead><tr><th>Clase</th><th>Responsabilidades</th><th>Colaboradores</th></tr></thead><tbody><tr><td>Venta</td><td>- Registrar la venta.<br/>- Calcular el total.<br/>- Generar recibo.</td><td>Producto, Cliente, Recibo</td></tr></tbody></table></div><br/><h5>Tarjeta CRC para la Clase Producto:</h5><br/><div class='scroll'><table><thead><tr><th>Clase</th><th>Responsabilidades</th><th>Colaboradores</th></tr></thead><tbody><tr><td>Producto</td><td>- Almacenar información del producto.<br/>- Calcular el precio.</td><td>Venta, Inventario</td></tr></tbody></table></div><br/><h5>Tarjeta CRC para la Clase Cliente:</h5><br/><div class='scroll'><table><thead><tr><th>Clase</th><th>Responsabilidades</th><th>Colaboradores</th></tr></thead><tbody><tr><td>Cliente</td><td>- Registrar datos del cliente.<br/>- Verificar historial de compras.</td><td>Venta, HistorialCompras</td></tr></tbody></table></div><br/><h5>Tarjeta CRC para la Clase Recibo:</h5><br/><div class='scroll'><table><thead><tr><th>Clase</th><th>Responsabilidades</th><th>Colaboradores</th></tr></thead><tbody><tr><td>Recibo</td><td>- Generar el recibo de la venta.<br/>- Imprimir recibo.</td><td>Venta</td></tr></tbody></table></div><br/><h5>Visualización de Relaciones:</h5><br/><div class='scroll'><div class='diagram'><div class='line'>Cliente -----------|> Venta <----------- Producto</div><div class='line'>|                                     |</div><div class='line'>|                                     |</div> <div class='line'>HistorialCompras     Inventario</div><div class='line'>|</div><div class='line'>|</div><div class='line'>Recibo</div></div></div><br/><br/>El principal beneficio de usar estas tarjetas es que permiten dividir las clases en componentes más manejables, facilitando la comprensión del prototipo de diseño. En el ejemplo anterior, podemos visualizar cómo se relaciona la clase Venta con las clases Producto, Cliente y Recibo, así como sus responsabilidades y colaboraciones específicas. Esto nos ayuda a identificar deficiencias en el diseño y simular cómo funcionan las clases en interacción."
    },
    {
        "slug": "disenio-de-software-acoplamiento-y-cohesion",
        "previous": "disenio-conceptual-con-tarjetas-crc",
        "next": "",
        "title": "Diseño de Software: Acoplamiento y Cohesión",
        "date": "24/08/2024",
        "summary": "Bajo acoplamiento y alta cohesión optimizan el diseño de software",
        "content": "Cuando un componente o módulo depende fuertemente de otro, se dice que están altamente acoplados. Para que nuestros módulos sean fácilmente integrables con otros, es fundamental buscar un bajo acoplamiento.<br/><br/><h5>Evaluación del Acoplamiento</h5><br/>Para evaluar el acoplamiento, debemos considerar tanto la cantidad de conexiones como la complejidad de estas interacciones. Un bajo acoplamiento implica que los módulos son independientes y flexibles, facilitando la implementación y los cambios. Esto significa que si las reglas de negocio requieren reemplazar o modificar componentes, el impacto será mínimo.<br/><br/>Aunque el acoplamiento se refiere a las interacciones externas entre módulos, el concepto de cohesión se enfoca en el comportamiento interno de un componente. La cohesión mide qué tan bien definido está el propósito y la responsabilidad de un componente.<br/><br/><h5>Cohesión Alta vs. Cohesión Baja</h5><br/>Una alta cohesión indica que un componente tiene un propósito claro y bien definido, y que todas sus responsabilidades están alineadas. Por el contrario, un componente con baja cohesión tiene múltiples responsabilidades no relacionadas, lo que puede indicar la necesidad de dividirlo en varios componentes más específicos.<br/><br/>Al identificar una baja cohesión, es probable que podamos refactorizar el componente para mejorar su diseño, dividiendo sus responsabilidades en componentes más especializados y manejables"
    }
]